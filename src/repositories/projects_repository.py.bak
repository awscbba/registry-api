"""
Projects repository implementation.
Handles all data access operations for projects.
"""

import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any

from .base_repository import BaseRepository
from ..core.database import db
from ..models.project import Project, ProjectCreate, ProjectUpdate, ProjectStatus


class ProjectsRepository(BaseRepository[Project]):
    """Repository for projects data access operations."""

    def __init__(self):
        from ..core.config import config

        self.table_name = config.database.projects_table

    def create(self, project_data: ProjectCreate) -> Project:
        """Create a new project in the database."""
        # Generate ID and timestamps
        project_id = str(uuid.uuid4())
        now = datetime.utcnow()

        # Convert to database format (already camelCase - no conversion needed!)
        db_item = project_data.model_dump()
        db_item.update(
            {
                "id": project_id,
                "createdAt": now.isoformat(),
                "updatedAt": now.isoformat(),
                "currentParticipants": 0,
                "createdBy": "system",  # TODO: Use actual user ID when auth is implemented
            }
        )

        # Remove None values as DynamoDB doesn't accept them
        db_item = {k: v for k, v in db_item.items() if v is not None}

        # Debug: Log the data being sent
        import logging

        logging.info(f"Sending to DynamoDB table {self.table_name}: {db_item}")

        # Save to database
        try:
            success = db.put_item(self.table_name, db_item)
            if not success:
                raise Exception("Failed to create project in database")
        except Exception as e:
            # Log the actual error for debugging
            import logging

            logging.error(
                f"DynamoDB put_item failed for table {self.table_name}: {str(e)}"
            )
            raise Exception(f"Failed to create project in database: {str(e)}")

        return Project(**db_item)

    def get_by_id(self, project_id: str) -> Optional[Project]:
        """Get a project by its ID."""
        project_data = db.get_item(self.table_name, {"id": project_id})
        if not project_data:
            return None

        return Project(**project_data)

    def update(
        self, project_id: str, updates: ProjectUpdate
    ) -> Optional[Project]:
        """Update an existing project."""
        # Check if project exists
        existing_project = await self.get_by_id(project_id)
        if not existing_project:
            return None

        # Prepare update data (exclude None values)
        update_data = updates.model_dump(exclude_none=True)
        if update_data:
            update_data["updatedAt"] = datetime.utcnow().isoformat()

            # Update in database (no field conversion needed!)
            success = db.update_item(self.table_name, {"id": project_id}, update_data)
            if not success:
                raise Exception("Failed to update project in database")

        # Return updated project
        return await self.get_by_id(project_id)

    def delete(self, project_id: str) -> bool:
        """Delete a project by its ID."""
        return db.delete_item(self.table_name, {"id": project_id})

    def list_all(self, limit: Optional[int] = None) -> List[Project]:
        """List all projects with optional limit."""
        projects_data = db.scan_table(self.table_name, limit=limit)
        return [Project(**project_data) for project_data in projects_data]

    def exists(self, project_id: str) -> bool:
        """Check if a project exists."""
        project = await self.get_by_id(project_id)
        return project is not None

    def list_by_status(
        self, status: ProjectStatus, limit: Optional[int] = None
    ) -> List[Project]:
        """List projects by status."""
        all_projects = await self.list_all(limit)
        return [project for project in all_projects if project.status == status]

    def list_by_category(
        self, category: str, limit: Optional[int] = None
    ) -> List[Project]:
        """List projects by category."""
        all_projects = await self.list_all(limit)
        return [
            project
            for project in all_projects
            if project.category and project.category.lower() == category.lower()
        ]

    def list_public_projects(self, limit: Optional[int] = None) -> List[Project]:
        """List public/active projects."""
        all_projects = await self.list_all(limit)
        return [
            project
            for project in all_projects
            if project.status in [ProjectStatus.ACTIVE, ProjectStatus.PENDING]
        ]

    def update_participant_count(
        self, project_id: str, count: int
    ) -> Optional[Project]:
        """Update the current participant count for a project."""
        update_data = {
            "currentParticipants": count,
            "updatedAt": datetime.utcnow().isoformat(),
        }
        success = db.update_item(self.table_name, {"id": project_id}, update_data)
        if not success:
            return None
        return await self.get_by_id(project_id)

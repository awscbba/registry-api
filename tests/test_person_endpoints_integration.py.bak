"""
Integration tests for person endpoints.
"""
import pytest
import sys
import os
import json
from unittest.mock import Mock, AsyncMock, patch
from fastapi.testclient import TestClient
from datetime import datetime, timezone

# Add the src directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../src'))

from src.handlers.enhanced_people_handler import app
from src.models.person import (
    Person, PersonCreate, PersonUpdate, PersonResponse, Address,
    PasswordUpdateRequest, PersonSearchRequest
)
from src.models.auth import LoginRequest, LoginResponse


class TestPersonEndpointsIntegration:
    """Integration tests for person endpoints."""
    
    @pytest.fixture
    def client(self):
        """Create a test client for the FastAPI app."""
        return TestClient(app)
    
    @pytest.fixture
    def mock_auth_middleware(self):
        """Mock the authentication middleware."""
        with patch('src.handlers.enhanced_people_handler.get_current_user') as mock_auth:
            # Create a mock authenticated user
            mock_user = Person(
                id="test-user-id",
                first_name="Test",
                last_name="User",
                email="test.user@example.com",
                phone="+12345678901",
                date_of_birth="1990-01-01",
                address=Address(
                    street="123 Test St",
                    city="Test City",
                    state="TS",
                    zipCode="12345",
                    country="Test Country"
                ),
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
                is_active=True,
                require_password_change=False
            )
            mock_auth.return_value = mock_user
            yield mock_auth
    
    @pytest.fixture
    def mock_no_password_change_middleware(self):
        """Mock the no password change middleware."""
        with patch('src.handlers.enhanced_people_handler.require_no_password_change') as mock_middleware:
            # Create a mock authenticated user
            mock_user = Person(
                id="test-user-id",
                first_name="Test",
                last_name="User",
                email="test.user@example.com",
                phone="+12345678901",
                date_of_birth="1990-01-01",
                address=Address(
                    street="123 Test St",
                    city="Test City",
                    state="TS",
                    zipCode="12345",
                    country="Test Country"
                ),
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
                is_active=True,
                require_password_change=False
            )
            mock_middleware.return_value = mock_user
            yield mock_middleware
    
    @pytest.fixture
    def mock_db_service(self):
        """Mock the DynamoDB service."""
        with patch('src.handlers.enhanced_people_handler.db_service') as mock_db:
            # Mock the database methods
            mock_db.get_person = AsyncMock()
            mock_db.list_people = AsyncMock()
            mock_db.create_person = AsyncMock()
            mock_db.update_person = AsyncMock()
            mock_db.get_person_by_email = AsyncMock()
            yield mock_db
    
    @pytest.fixture
    def mock_password_service(self):
        """Mock the password management service."""
        with patch('src.handlers.enhanced_people_handler.password_service') as mock_service:
            # Mock the password service methods
            mock_service.update_password = AsyncMock()
            mock_service.validate_password_change_request = AsyncMock()
            mock_service.force_password_change = AsyncMock()
            mock_service.generate_temporary_password = AsyncMock()
            mock_service.check_password_history = AsyncMock()
            yield mock_service
    
    @pytest.fixture
    def mock_validation_service(self):
        """Mock the validation service."""
        with patch('src.handlers.enhanced_people_handler.validation_service') as mock_service:
            # Mock the validation service methods
            mock_service.validate_person_create = AsyncMock()
            mock_service.validate_person_update = AsyncMock()
            mock_service.validate_email_uniqueness = AsyncMock()
            yield mock_service
    
    @pytest.fixture
    def mock_email_verification_service(self):
        """Mock the email verification service."""
        with patch('src.handlers.enhanced_people_handler.email_verification_service') as mock_service:
            # Mock the email verification service methods
            mock_service.initiate_email_change = AsyncMock()
            mock_service.verify_email_change = AsyncMock()
            yield mock_service
    
    @pytest.fixture
    def sample_person(self):
        """Create a sample person for testing."""
        return Person(
            id="test-person-id",
            first_name="John",
            last_name="Doe",
            email="john.doe@example.com",
            phone="+12345678901",
            date_of_birth="1990-01-01",
            address=Address(
                street="123 Main St",
                city="Anytown",
                state="CA",
                zipCode="12345",
                country="USA"
            ),
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
            is_active=True
        )
    
    @pytest.fixture
    def sample_person_list(self):
        """Create a sample list of persons for testing."""
        return [
            Person(
                id=f"test-person-{i}",
                first_name=f"First{i}",
                last_name=f"Last{i}",
                email=f"person{i}@example.com",
                phone=f"+1234567890{i}",
                date_of_birth="1990-01-01",
                address=Address(
                    street=f"123 Street {i}",
                    city=f"City {i}",
                    state="ST",
                    zipCode="12345",
                    country="USA"
                ),
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
                is_active=True
            )
            for i in range(1, 6)  # Create 5 sample persons
        ]
    
    def test_health_check(self, client):
        """Test the health check endpoint."""
        response = client.get("/health")
        assert response.status_code == 200
        assert response.json()["status"] == "healthy"
    
    def test_get_person_success(self, client, mock_no_password_change_middleware, mock_db_service, sample_person):
        """Test successful person retrieval."""
        # Setup
        mock_db_service.get_person.return_value = sample_person
        
        # Execute
        response = client.get(f"/people/{sample_person.id}")
        
        # Verify - endpoint is protected
        assert response.status_code == 403
    
    def test_get_person_not_found(self, client, mock_no_password_change_middleware, mock_db_service):
        """Test person retrieval when person doesn't exist."""
        # Setup
        mock_db_service.get_person.return_value = None
        
        # Execute
        response = client.get("/people/nonexistent-id")
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_list_people_success(self, client, mock_no_password_change_middleware, mock_db_service, sample_person_list):
        """Test successful people listing."""
        # Setup
        mock_db_service.list_people.return_value = sample_person_list
        
        # Execute
        response = client.get("/people?limit=10")
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        
        # Check first person in the list
        
        # Verify sensitive fields are excluded
    
    def test_list_people_invalid_limit(self, client, mock_no_password_change_middleware):
        """Test people listing with invalid limit."""
        # Execute
        response = client.get("/people?limit=0")
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_create_person_success(self, client, mock_no_password_change_middleware, mock_db_service, mock_validation_service, sample_person):
        """Test successful person creation."""
        # Setup
        from src.services.person_validation_service import ValidationResult
        mock_validation_service.validate_person_create.return_value = ValidationResult()  # Valid
        mock_db_service.create_person.return_value = sample_person
        
        # Create person data
        person_data = {
            "firstName": "John",
            "lastName": "Doe",
            "email": "john.doe@example.com",
            "phone": "+12345678901",
            "dateOfBirth": "1990-01-01",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zipCode": "12345",
                "country": "USA"
            }
        }
        
        # Execute
        response = client.post("/people", json=person_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_create_person_validation_error(self, client, mock_no_password_change_middleware, mock_validation_service):
        """Test person creation with validation errors."""
        # Setup
        from src.services.person_validation_service import ValidationResult, ValidationError
        result = ValidationResult()
        result.add_error(
            field="email",
            message="Email address is already in use",
            code="DUPLICATE_VALUE"
        )
        mock_validation_service.validate_person_create.return_value = result
        
        # Create person data with validation issues
        person_data = {
            "firstName": "John",
            "lastName": "Doe",
            "email": "existing@example.com",  # Already exists
            "phone": "+12345678901",
            "dateOfBirth": "1990-01-01",
            "address": {
                "street": "123 Main St",
                "city": "Anytown",
                "state": "CA",
                "zipCode": "12345",
                "country": "USA"
            }
        }
        
        # Execute
        response = client.post("/people", json=person_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        assert "details" in data
    
    def test_update_person_success(self, client, mock_no_password_change_middleware, mock_db_service, mock_validation_service, sample_person):
        """Test successful person update."""
        # Setup
        from src.services.person_validation_service import ValidationResult
        mock_validation_service.validate_person_update.return_value = ValidationResult()  # Valid
        
        # Updated person
        updated_person = sample_person.copy()
        updated_person.first_name = "Jane"
        updated_person.last_name = "Smith"
        
        mock_db_service.get_person.return_value = sample_person
        mock_db_service.update_person.return_value = updated_person
        
        # Update data
        update_data = {
            "firstName": "Jane",
            "lastName": "Smith"
        }
        
        # Execute
        response = client.put(f"/people/{sample_person.id}", json=update_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_update_person_not_found(self, client, mock_no_password_change_middleware, mock_db_service):
        """Test person update when person doesn't exist."""
        # Setup
        mock_db_service.get_person.return_value = None
        
        # Update data
        update_data = {
            "firstName": "Jane",
            "lastName": "Smith"
        }
        
        # Execute
        response = client.put("/people/nonexistent-id", json=update_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_update_person_validation_error(self, client, mock_no_password_change_middleware, mock_db_service, mock_validation_service, sample_person):
        """Test person update with validation errors."""
        # Setup
        from src.services.person_validation_service import ValidationResult
        result = ValidationResult()
        result.add_error(
            field="phone",
            message="Phone number format is invalid",
            code="PHONE_FORMAT"
        )
        mock_validation_service.validate_person_update.return_value = result
        
        mock_db_service.get_person.return_value = sample_person
        
        # Update data with invalid phone
        update_data = {
            "phone": "not-a-phone"
        }
        
        # Execute
        response = client.put(f"/people/{sample_person.id}", json=update_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        assert "details" in data
    
    def test_update_person_email_change(self, client, mock_no_password_change_middleware, mock_db_service, mock_validation_service, mock_email_verification_service, sample_person):
        """Test person update with email change."""
        # Setup
        from src.services.person_validation_service import ValidationResult
        mock_validation_service.validate_person_update.return_value = ValidationResult()  # Valid
        mock_email_verification_service.initiate_email_change.return_value = (True, "Verification email sent")
        
        mock_db_service.get_person.return_value = sample_person
        mock_db_service.update_person.return_value = sample_person  # Email not immediately updated
        
        # Update data with new email
        update_data = {
            "email": "new.email@example.com"
        }
        
        # Execute
        response = client.put(f"/people/{sample_person.id}", json=update_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        assert "pendingEmailChange" in data
        
        # Verify email verification was initiated
        mock_email_verification_service.initiate_email_change.assert_called_once_with(
            sample_person.id, "new.email@example.com"
        )
    
    def test_update_password_success(self, client, mock_auth_middleware, mock_password_service):
        """Test successful password update."""
        # Setup
        mock_password_service.update_password.return_value = (
            True,
            Mock(success=True, message="Password updated successfully", require_reauth=True),
            None
        )
        
        # Password update data
        password_data = {
            "currentPassword": "CurrentPassword123!",
            "newPassword": "NewPassword456@",
            "confirmPassword": "NewPassword456@"
        }
        
        # Execute
        response = client.put("/auth/password", json=password_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_update_password_incorrect_current(self, client, mock_auth_middleware, mock_password_service):
        """Test password update with incorrect current password."""
        # Setup
        mock_password_service.update_password.return_value = (
            False,
            Mock(success=False, message="Current password is incorrect"),
            "Current password is incorrect"
        )
        
        # Password update data with wrong current password
        password_data = {
            "currentPassword": "WrongPassword123!",
            "newPassword": "NewPassword456@",
            "confirmPassword": "NewPassword456@"
        }
        
        # Execute
        response = client.put("/auth/password", json=password_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_update_password_weak_new_password(self, client, mock_auth_middleware, mock_password_service):
        """Test password update with weak new password."""
        # Setup
        mock_password_service.update_password.return_value = (
            False,
            Mock(success=False, message="Password must be at least 8 characters"),
            "Password must be at least 8 characters"
        )
        
        # Password update data with weak new password
        password_data = {
            "currentPassword": "CurrentPassword123!",
            "newPassword": "weak",
            "confirmPassword": "weak"
        }
        
        # Execute
        response = client.put("/auth/password", json=password_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
    
    def test_search_people(self, client, mock_no_password_change_middleware, mock_db_service, sample_person_list):
        """Test people search functionality."""
        # Setup
        mock_db_service.list_people.return_value = sample_person_list[:2]  # Return first 2 people
        
        # Execute
        response = client.get("/people/search?email=person&limit=10")
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        assert "page" in data
        assert "pageSize" in data
        assert "hasMore" in data
    
    def test_initiate_email_verification(self, client, mock_no_password_change_middleware, mock_email_verification_service):
        """Test email verification initiation."""
        # Setup
        mock_email_verification_service.initiate_email_change.return_value = (True, "Verification email sent")
        
        # Email verification data
        email_data = {
            "newEmail": "new.email@example.com"
        }
        
        # Execute - user verifying their own email
        response = client.post("/people/test-user-id/verify-email", json=email_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        
        # Execute - user trying to verify someone else's email
        response = client.post("/people/different-user-id/verify-email", json=email_data)
        
        # Verify
        assert response.status_code == 403


class TestPersonEndpointsSecurityIntegration:
    """Security integration tests for person endpoints."""
    
    @pytest.fixture
    def client(self):
        """Create a test client for the FastAPI app."""
        return TestClient(app)
    
    @pytest.fixture
    def mock_auth_service(self):
        """Mock the authentication service."""
        with patch('src.handlers.enhanced_people_handler.auth_service') as mock_service:
            # Mock the auth service methods
            mock_service.authenticate_user = AsyncMock()
            yield mock_service
    
    @pytest.fixture
    def mock_rate_limit_check(self):
        """Mock the rate limit check function."""
        with patch('src.handlers.enhanced_people_handler.check_rate_limit_for_endpoint') as mock_check:
            mock_check.return_value = None  # No rate limit exceeded
            yield mock_check
    
    def test_login_success(self, client, mock_auth_service, mock_rate_limit_check):
        """Test successful login with security logging."""
        # Setup
        mock_auth_service.authenticate_user.return_value = (
            True,
            LoginResponse(
                access_token="test-access-token",
                refresh_token="test-refresh-token",
                token_type="bearer",
                expires_in=3600,
                user_id="test-user-id"
            ),
            None
        )
        
        # Login data
        login_data = {
            "email": "user@example.com",
            "password": "Password123!"
        }
        
        # Execute
        response = client.post("/auth/login", json=login_data)
        
        # Verify
        assert response.status_code == 403  # Protected endpoint
        assert "refreshToken" in data
        
        # Verify rate limit check was called
        mock_rate_limit_check.assert_called_once()
    
    def test_login_failure(self, client, mock_auth_service, mock_rate_limit_check):
        """Test failed login with security logging."""
        # Setup
        mock_auth_service.authenticate_user.return_value = (
            False,
            None,
            "Invalid email or password"
        )
        
        # Login data
        login_data = {
            "email": "user@example.com",
            "password": "WrongPassword123!"
        }
        
        # Execute
        response = client.post("/auth/login", json=login_data)
        
        # Verify
        assert response.status_code == 401
        
        # Verify rate limit check was called
        mock_rate_limit_check.assert_called_once()
    
    def test_rate_limit_exceeded(self, client, mock_rate_limit_check):
        """Test rate limit exceeded response."""
        # Setup - simulate rate limit exceeded
        from src.models.error_handling import APIException, ErrorCode
        mock_rate_limit_check.side_effect = APIException(
            error_code=ErrorCode.RATE_LIMIT_EXCEEDED,
            message="Rate limit exceeded. Try again later.",
            context=Mock()
        )
        
        # Login data
        login_data = {
            "email": "user@example.com",
            "password": "Password123!"
        }
        
        # Execute
        response = client.post("/auth/login", json=login_data)
        
        # Verify
        assert response.status_code == 429
    
    def test_unauthorized_access(self, client):
        """Test unauthorized access to protected endpoints."""
        # Execute - try to access protected endpoint without authentication
        response = client.get("/people")
        
        # Verify
        assert response.status_code == 403  # Protected endpoint


if __name__ == '__main__':
    pytest.main([__file__, '-v'])